{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;AAAA,MAAM,cAAc,GAAG,IAAI,CAAC;AAC5B,MAAM,UAAU,GAAG,GAAG,CAAC;AACvB,MAAM,WAAW,GAAG,IAAI,CAAC;AAIzB;;GAEG;AACH,SAAgB,OAAO,CAAC,KAAa,EAAE,WAAW,GAAG,UAAU;IAC7D,IAAI,MAAM,GAAG,UAAU,CAAC;IACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACrC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAEtB,4CAA4C;QAC5C,IAAI,IAAI,KAAK,UAAU,IAAI,IAAI,KAAK,WAAW,EAAE;YAC/C,MAAM,IAAI,WAAW,CAAC;SACvB;QAED,0BAA0B;QAC1B,IAAI,IAAI,KAAK,GAAG,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;YACxC,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;YACpB,IAAI,GAAG,GAAG,CAAC,CAAC;YACZ,IAAI,YAAY,GAAG,EAAE,CAAC;YAEtB,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACzC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAI,YAAY,EAAE;oBAChB,IAAI,IAAI,KAAK,WAAW;wBAAE,CAAC,EAAE,CAAC;yBACzB,IAAI,IAAI,KAAK,YAAY;wBAAE,YAAY,GAAG,EAAE,CAAC;oBAClD,SAAS;iBACV;qBAAM,IAAI,IAAI,KAAK,GAAG,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;oBAC/C,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBACV,GAAG,GAAG,CAAC,CAAC;oBACR,MAAM;iBACP;qBAAM,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,GAAG,EAAE;oBACvD,YAAY,GAAG,IAAI,CAAC;iBACrB;aACF;YAED,IAAI,CAAC,GAAG;gBAAE,MAAM,IAAI,SAAS,CAAC,oCAAoC,CAAC,EAAE,CAAC,CAAC;YAEvE,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;YAC7C,MAAM,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;YACxC,MAAM,IAAI,GAAG,UAAU,OAAO,cAAc,GAAG,GAAG,GAAG,KAAK,OAAO,UAAU,EAAE,CAAC;YAC9E,SAAS;SACV;QAED,MAAM,IAAI,IAAI,CAAC;KAChB;IACD,MAAM,IAAI,UAAU,CAAC;IAErB,OAAO,YAAY,WAAW,IAAI,cAAc,cAAc,MAAM,KAAK,CAAC;AAC5E,CAAC;AA5CD,0BA4CC;AAED;;GAEG;AACH,SAAgB,QAAQ,CACtB,KAAa,EACb,WAAoB;IAEpB,MAAM,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;IACzC,OAAO,IAAI,QAAQ,CAAC,WAAW,IAAI,IAAI,CAAC,EAAiB,CAAC;AAC5D,CAAC;AAND,4BAMC","sourcesContent":["const INPUT_VAR_NAME = \"it\";\nconst QUOTE_CHAR = '\"';\nconst ESCAPE_CHAR = \"\\\\\";\n\nexport type Template<T extends object> = (data: T) => string;\n\n/**\n * Stringify a template into a function.\n */\nexport function compile(value: string, displayName = \"template\") {\n  let result = QUOTE_CHAR;\n  for (let i = 0; i < value.length; i++) {\n    const char = value[i];\n\n    // Escape special characters due to quoting.\n    if (char === QUOTE_CHAR || char === ESCAPE_CHAR) {\n      result += ESCAPE_CHAR;\n    }\n\n    // Process template param.\n    if (char === \"{\" && value[i + 1] === \"{\") {\n      const start = i + 2;\n      let end = 0;\n      let withinString = \"\";\n\n      for (let j = start; j < value.length; j++) {\n        const char = value[j];\n        if (withinString) {\n          if (char === ESCAPE_CHAR) j++;\n          else if (char === withinString) withinString = \"\";\n          continue;\n        } else if (char === \"}\" && value[j + 1] === \"}\") {\n          i = j + 1;\n          end = j;\n          break;\n        } else if (char === '\"' || char === \"'\" || char === \"`\") {\n          withinString = char;\n        }\n      }\n\n      if (!end) throw new TypeError(`Template parameter not closed at ${i}`);\n\n      const param = value.slice(start, end).trim();\n      const sep = param[0] === \"[\" ? \"\" : \".\";\n      result += `${QUOTE_CHAR} + (${INPUT_VAR_NAME}${sep}${param}) + ${QUOTE_CHAR}`;\n      continue;\n    }\n\n    result += char;\n  }\n  result += QUOTE_CHAR;\n\n  return `function ${displayName}(${INPUT_VAR_NAME}) { return ${result}; }`;\n}\n\n/**\n * Fast and simple string templates.\n */\nexport function template<T extends object = object>(\n  value: string,\n  displayName?: string\n) {\n  const body = compile(value, displayName);\n  return new Function(`return (${body});`)() as Template<T>;\n}\n"]}